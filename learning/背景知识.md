# wiki
- LevelDB 是一个开源的磁盘键值存储系统，由谷歌研究员Jeffrey Dean和Sanjay Ghemawat编写。采用新 BSD 许可证，并且已被移植到多种基于 Unix 的系统、macOS、Windows 和 Android 系统。
- 特征：LevelDB 将键和值存储在任意字节数组中，数据按键排序。它支持批量写入、正向和反向迭代，并通过 Google 的 Snappy 压缩库对数据进行压缩。LevelDB 不是一个 SQL 数据库，它没有关系型数据模型，也不支持 SQL 查询。此外，它不支持索引。应用程序将 LevelDB 用作一个库，因为它不提供服务器或命令行界面。
- 历史：基于谷歌 Bigtable 数据库系统的理念。
- 使用：LevelDB 被用作谷歌浏览器 IndexedDB 的后端数据库，也是 Riak 支持的后端之一。此外，比特币核心（Bitcoin Core）和以太坊客户端（go-ethereum）使用 LevelDB 数据库存储区块链元数据。《我的世界》基岩版（Minecraft Bedrock Edition）使用其修改版本来存储区块和实体数据。AutoCAD 2016 也使用了 LevelDB。
- 表现：谷歌提供了在不同场景下将 LevelDB 的性能与 SQLite 和 Kyoto Cabinet 进行比较的基准测试。在写入操作和顺序读取操作中，LevelDB 的性能优于 SQLite 和 Kyoto Cabinet。LevelDB 在批量写入方面也表现出色，但在处理大型值时比 SQLite 慢。更新后的基准测试显示，LevelDB 的性能也优于 Berkeley DB，但这些测试还表明，OpenLDAP LightningDB 在读取操作和某些写入类型（方面快得多（在某些场景下约快 10 倍），而在其余测试中则几乎不相上下。
- Bugs和可靠性：LevelDB 存在数据库损坏漏洞的历史。2014 年的一项研究发现，在非校验和文件系统上，数据库可能会在崩溃或断电后损坏

# 使用及了解
- LevelDB 是 Google 编写的一个快速键值存储库，它提供从字符串键到字符串值的有序映射。
## 特点
- 键和值都是任意字节数组；
- 数据按键排序存储；
- 调用者可以提供自定义比较函数来覆盖排序顺序；
- 基本操作有：Put(key,value)、Get(key)、Delete(key)；
- 在一个原子批次中可以进行多次更改；
- 用户可以创建临时快照，以获得一致的数据视图；
- 支持对数据进行前向和后向迭代；
- 数据会自动使用 Snappy 压缩库进行压缩，但也支持 Zstd 压缩；
- 外部活动（例如文件系统操作）通过虚拟接口进行传递，以便用户可以自定义操作系统交互。

## [参考文档](https://github.com/google/leveldb/blob/main/doc/index.md)
## 局限性
- 不是SQL数据库。它没有关系数据模型，不支持SQL查询，也不支持索引；
- 一次只能有一个进程（可能是多线程的）访问特定的数据库；
- 该库本身不具备客户端-服务器支持。需要此类支持的应用程序必须自行封装服务器端。

## Getting the Source
git clone --recurse-submodules https://github.com/google/leveldb.git

## 构建
该项目开箱即用，支持 CMake
### Build for POSIX
Quick start:
```
mkdir -p build && cd build
cmake -DCMAKE_BUILD_TYPE=Release .. && cmake --build .
```

|部分|作用说明|
|----|----|
|mkdir|英文 “make directory”，Linux/macOS/Windows（PowerShell）通用的 “创建目录” 命令|
|-p|mkdir 的核心参数（全称 --parents），关键作用有两个：支持创建 “多级目录”（比如 mkdir -p a/b/c 会自动创建 a、a/b、a/b/c）；若目标目录（如 build）已存在，不会报错（默认 mkdir build 若目录存在会报错）|
|build|要创建的目录名（约定俗成的命名，也可叫 build_dir 等，含义一致）|
|&&|shell 中的 “逻辑与” 运算符，规则：只有前面的命令（mkdir -p build）执行成功（返回码 0），才执行后面的命令；若前面命令失败（比如权限不足），后面命令直接跳过，避免无效操作。|
|cd build|英文 “change directory”，进入刚创建的 build 目录（后续所有操作都在该目录执行）|
|cmake|跨平台构建工具的核心命令，核心功能：读取源码目录的 CMakeLists.txt（构建配置文件），生成对应平台的 “编译脚本”（如 Linux 的 Makefile、Windows 的 .sln）|
|-D|CMake 的 “定义变量” 参数（-D = Define），用于给 CMake 传递自定义配置变量|
|CMAKE_BUILD_TYPE=Release|定义 CMake 内置变量 CMAKE_BUILD_TYPE，值为 Release（发布版），关键作用：- Release 模式：编译器会开启优化编译（如代码压缩、指令重排、删除冗余代码），生成的二进制文件体积小、运行速度快，但不包含调试信息（无法用 gdb 调试）；- 对比 Debug 模式：CMAKE_BUILD_TYPE=Debug 会关闭优化，保留调试信息（变量、断点支持），用于开发 / 调试阶段（编译速度慢、二进制体积大）；- 其他常见类型：RelWithDebInfo（Release + 调试信息）、MinSizeRel（最小体积优化）|
|cmake --build|CMake 提供的 “统一构建命令”，跨平台通用，无需关心底层编译工具（如 Make、Visual Studio）|
|.|表示 “当前目录”（即 build 目录），告诉 CMake：在当前目录中执行编译（使用前面生成的编译脚本）|
- 为什么要创建 build 目录？\
这是 C/C++ 项目的 “Out-of-Source Build（源码外构建）” 最佳实践，核心优势：分离 “源码” 和 “编译产物”：编译生成的二进制文件（如 leveldb.so）、中间文件（.o 目标文件）、配置文件等，全放在 build 目录中，源码目录（如 leveldb/）只会保留原始代码（.h/.c/.cpp）和配置文件（CMakeLists.txt），不会被污染；方便清理 / 重新构建：想删除所有编译产物时，直接 rm -rf build 即可，不用手动筛选源码目录中的临时文件；支持多构建类型：比如同时创建 build_debug（调试版）和 build_release（发布版），切换构建类型时互不干扰。

## 性能

## Repository contents
更多说明请参见[doc/index.md](https://github.com/google/leveldb/blob/main/doc/index.md)。实现概要请参见[doc/impl.md](https://github.com/google/leveldb/blob/main/doc/impl.md).\
公共接口位于 include/leveldb/*.h 中。调用者不应包含或依赖此包中任何其他头文件的详细信息。这些内部 API 可能会在不另行通知的情况下进行更改。
### 头文件指南：
- include/leveldb/db.h：数据库的主要接口：从这里开始
- include/leveldb/options.h：控制整个数据库的行为，以及控制单个读取和写入操作的行为
- include/leveldb/comparator.h：用户指定比较函数的抽象。如果您只需要对键进行按字节比较，可以使用默认比较器，但如果客户端想要自定义排序（例如，处理不同的字符编码等），则可以编写自己的比较器实现
- include/leveldb/iterator.h：用于迭代数据的接口。您可以从数据库对象获取迭代器
- include/leveldb/write_batch.h：用于原子地将多个更新应用到数据库的接口
- include/leveldb/slice.h：一个简单的模块，用于维护指向另一个字节数组的指针和长度
- include/leveldb/status.h：状态由许多公共接口返回，用于报告成功和各种类型的错误
- include/leveldb/env.h：操作系统环境的抽象。该接口的 POSIX 实现位于 util/env_posix.cc 中
- include/leveldb/table_builder.h：这些是底层模块，大多数客户端可能不会直接使用
